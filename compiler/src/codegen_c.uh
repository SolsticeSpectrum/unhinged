⍝ Emit C code from AST (minimal, matches bootstrap runtime ABI)

"runtime/rt.h" → RT_HEADER ¿

⍝ Escape strings for C literals.
ƒ
  "" → out ¿
  s ⟪ len ⟫ → n ¿
  0 → i ¿
  i n ≺ ⟲ ↵
    s i ⟪ char_at ⟫ → ch ¿
    ch "\\" ≡ ⤴ ↵ out "\\\\" ⊞⊞ → out ¿ i 1 ⊞ → i ¿ ⊕ ¿ ⌫ ¿
    ch "\"" ≡ ⤴ ↵ out "\\\"" ⊞⊞ → out ¿ i 1 ⊞ → i ¿ ⊕ ¿ ⌫ ¿
    ch "\n" ≡ ⤴ ↵ out "\\n" ⊞⊞ → out ¿ i 1 ⊞ → i ¿ ⊕ ¿ ⌫ ¿
    ch "\r" ≡ ⤴ ↵ out "\\r" ⊞⊞ → out ¿ i 1 ⊞ → i ¿ ⊕ ¿ ⌫ ¿
    ch "\t" ≡ ⤴ ↵ out "\\t" ⊞⊞ → out ¿ i 1 ⊞ → i ¿ ⊕ ¿ ⌫ ¿
    out ch ⊞⊞ → out ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  out ⇄ ¿
↦ s ↦ escape_c_string ¿

ƒ
  【】 → parts ¿
  parts "#include \"runtime/rt.h\"\n#include <string.h>\n\n" ⟪ append ⟫ → parts ¿

  program "functions" ⌈ ⌉ → funcs ¿
  ❴❵ → funmap ¿
  【】 → fnames ¿
  0 → i ¿
  funcs ⟪ len ⟫ → n ¿
  i n ≺ ⟲ ↵
    funcs i ⌈ ⌉ "name" ⌈ ⌉ → name ¿
    funcs i ⌈ ⌉ "params" ⌈ ⌉ ⟪ len ⟫ → argc ¿
    funmap name ← argc ¿
    fnames name ⟪ .append ⟫ → fnames ¿
    "static UhValue uh_fn_" name ⊞⊞ "(UhEnv *env" ⊞⊞ → line ¿
    0 → j ¿
    j argc ≺ ⟲ ↵
      line ", UhValue a" ⊞⊞ j ⍕ ⊞⊞ → line ¿
      j 1 ⊞ → j ¿
    ⌫ ¿
    line ");\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  funmap "keys" ← fnames ¿
  parts "\n" ⟪ append ⟫ → parts ¿

  0 → i ¿
  i n ≺ ⟲ ↵
    funcs i ⌈ ⌉ → fn ¿
    fn funmap ⟪ emit_function ⟫ → fnc ¿
    parts fnc ⟪ append ⟫ → parts ¿
    parts "\n" ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿

  parts "UhValue uh_call_named(UhEnv *env, const char *name, int argc, UhValue *args) {\n" ⟪ append ⟫ → parts ¿
  parts "  if (!name) return uh_num(0);\n" ⟪ append ⟫ → parts ¿
  0 → i ¿
  i n ≺ ⟲ ↵
    fnames i ⌈ ⌉ → fname ¿
    funmap fname ⌈ ⌉ → fargc ¿
    fname ⟪ escape_c_string ⟫ → fesc ¿
    "  if (strcmp(name, \"" fesc ⊞⊞ "\") == 0) {\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    "    if (argc != " fargc ⊞⊞ ") return uh_num(0);\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    "    return uh_fn_" fname ⊞⊞ "(env" ⊞⊞ → line ¿
    0 → j ¿
    j fargc ≺ ⟲ ↵
      line ", args[" ⊞⊞ j ⍕ ⊞⊞ "]" ⊞⊞ → line ¿
      j 1 ⊞ → j ¿
    ⌫ ¿
    line ");\n  }\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  parts "  return uh_num(0);\n}\n\n" ⟪ append ⟫ → parts ¿

  parts "int main(int argc, char **argv) {\n  uh_set_args(argc, argv);\n  UhEnv env; uh_env_init(&env, NULL);\n  uh_set_global_env(&env);\n  UhStack st; uh_stack_init(&st);\n  uh_env_set(&env, \"⎕\", uh_sysobj());\n" ⟪ append ⟫ → parts ¿
  program "main" ⌈ ⌉ funmap ⟪ emit_block ⟫ → body ¿
  parts body ⟪ append ⟫ → parts ¿
  parts "  return 0;\n}\n" ⟪ append ⟫ → parts ¿

  parts "" ⟪ join ⟫ ⇄ ¿
↦ program ↦ emit_c ¿

ƒ
  fn "name" ⌈ ⌉ → name ¿
  fn "params" ⌈ ⌉ → params ¿
  params ⟪ len ⟫ → argc ¿

  【】 → parts ¿
  "static UhValue uh_fn_" name ⊞⊞ "(UhEnv *parent" ⊞⊞ → head ¿
  0 → i ¿
  i argc ≺ ⟲ ↵
    head ", UhValue a" ⊞⊞ i ⍕ ⊞⊞ → head ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  head ") {\n  UhEnv env; uh_env_init(&env, parent);\n  UhStack st; uh_stack_init(&st);\n" ⊞⊞ → head ¿
  parts head ⟪ append ⟫ → parts ¿

  0 → i ¿
  i argc ≺ ⟲ ↵
    params i ⌈ ⌉ → p ¿
    "  uh_env_set(&env, \"" p ⊞⊞ "\", a" ⊞⊞ i ⍕ ⊞⊞ ");\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿

  fn "body" ⌈ ⌉ funmap ⟪ emit_block ⟫ → body ¿
  parts body ⟪ append ⟫ → parts ¿
  parts "  return uh_num(0);\n}\n" ⟪ append ⟫ → parts ¿
  parts "" ⟪ join ⟫ ⇄ ¿
↦ fn ↦ funmap ↦ emit_function ¿

ƒ
  【】 → parts ¿
  0 → i ¿
  stmts ⟪ len ⟫ → n ¿
  i n ≺ ⟲ ↵
    stmts i ⌈ ⌉ → s ¿
    s "kind" ⌈ ⌉ → k ¿
    k "for" ≡ ⤴ ↵
      s funmap ⟪ emit_for ⟫ → piece ¿
    ⌫ ⤵ ↵
      s funmap ⟪ emit_stmt ⟫ → piece ¿
    ⌫ ¿
    parts "{\n" ⟪ append ⟫ → parts ¿
    parts piece ⟪ append ⟫ → parts ¿
    parts "}\n" ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  parts "" ⟪ join ⟫ ⇄ ¿
↦ stmts ↦ funmap ↦ emit_block ¿

ƒ
  stmt "iter" ⌈ ⌉ → iterName ¿
  stmt "range" ⌈ ⌉ → rangeSpec ¿
  stmt "expr" ⌈ ⌉ → seqExpr ¿
  stmt "body" ⌈ ⌉ funmap ⟪ emit_block ⟫ → body ¿
  【】 → parts ¿
  rangeSpec ∅ ≢ ⤴ ↵
    rangeSpec 0 ⌈ ⌉ → startExpr ¿
    rangeSpec 1 ⌈ ⌉ → endExpr ¿
    【startExpr】 funmap ⟪ emit_expr ⟫ → startCode ¿
    【endExpr】 funmap ⟪ emit_expr ⟫ → endCode ¿
    parts startCode ⟪ append ⟫ → parts ¿
    parts endCode ⟪ append ⟫ → parts ¿
    parts "  UhValue _end = uh_stack_pop(&st);\n  UhValue _start = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
    parts "  for (long _i = (long)_start.num; _i < (long)_end.num; _i++) {\n" ⟪ append ⟫ → parts ¿
    "  uh_env_set(&env, \"" iterName ⊞⊞ "\", uh_num((double)_i));\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    parts body ⟪ append ⟫ → parts ¿
    parts "  }\n" ⟪ append ⟫ → parts ¿
  ⌫ ⤵ ↵
    seqExpr funmap ⟪ emit_expr ⟫ → seqCode ¿
    parts seqCode ⟪ append ⟫ → parts ¿
    parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
    parts "  if (_seq.tag == UH_ARR && _seq.arr) {\n" ⟪ append ⟫ → parts ¿
    parts "    for (size_t _i = 0; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
    "      uh_env_set(&env, \"" iterName ⊞⊞ "\", _seq.arr->items[_i]);\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    parts body ⟪ append ⟫ → parts ¿
    parts "    }\n  } else if (_seq.tag == UH_STR && _seq.str) {\n" ⟪ append ⟫ → parts ¿
    parts "    long _len = (long)uh_len(_seq).num;\n" ⟪ append ⟫ → parts ¿
    parts "    for (long _i = 0; _i < _len; _i++) {\n" ⟪ append ⟫ → parts ¿
    parts "      UhValue _ch = uh_char_at(_seq, uh_num((double)_i));\n" ⟪ append ⟫ → parts ¿
    "      uh_env_set(&env, \"" iterName ⊞⊞ "\", _ch);\n" ⊞⊞ → line ¿
    parts line ⟪ append ⟫ → parts ¿
    parts body ⟪ append ⟫ → parts ¿
    parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
  ⌫ ¿
  parts "" ⟪ join ⟫ ⇄ ¿
↦ stmt ↦ funmap ↦ emit_for ¿

ƒ
  stmt "kind" ⌈ ⌉ → k ¿

  k "expr" ≡ ⤴ ↵
    stmt "expr" ⌈ ⌉ funmap ⟪ emit_expr ⟫ → e ¿
    【】 → parts ¿
    parts e ⟪ append ⟫ → parts ¿
    parts "  uh_stack_clear(&st);\n" ⟪ append ⟫ → parts ¿
    parts "" ⟪ join ⟫ ⇄ ¿
  ⌫ ¿

  k "return" ≡ ⤴ ↵
    stmt "expr" ⌈ ⌉ → rexpr ¿
    rexpr ∅ ≡ ⤴ ↵
      "  return uh_num(0);\n" ⇄ ¿
    ⌫ ¿
    rexpr funmap ⟪ emit_expr ⟫ → e ¿
    【】 → parts ¿
    parts e ⟪ append ⟫ → parts ¿
    parts "  UhValue _ret = uh_stack_pop(&st);\n  return _ret;\n" ⟪ append ⟫ → parts ¿
    parts "" ⟪ join ⟫ ⇄ ¿
  ⌫ ¿

  k "break" ≡ ⤴ ↵ "  break;\n" ⇄ ¿ ⌫ ¿
  k "continue" ≡ ⤴ ↵ "  continue;\n" ⇄ ¿ ⌫ ¿

  k "if" ≡ ⤴ ↵
    stmt "cond" ⌈ ⌉ funmap ⟪ emit_expr ⟫ → cond ¿
    stmt "then" ⌈ ⌉ funmap ⟪ emit_block ⟫ → thenBlk ¿
    stmt "else" ⌈ ⌉ → elseBlk ¿
    【】 → parts ¿
    parts cond ⟪ append ⟫ → parts ¿
    parts "  UhValue _cond = uh_stack_pop(&st);\n  if (uh_is_true(_cond)) {\n" ⟪ append ⟫ → parts ¿
    parts thenBlk ⟪ append ⟫ → parts ¿
    parts "  }" ⟪ append ⟫ → parts ¿
    elseBlk ∅ ≢ ⤴ ↵
      elseBlk funmap ⟪ emit_block ⟫ → elseC ¿
      parts " else {\n" ⟪ append ⟫ → parts ¿
      parts elseC ⟪ append ⟫ → parts ¿
      parts "  }\n" ⟪ append ⟫ → parts ¿
    ⌫ ⤵ ↵
      parts "\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    parts "" ⟪ join ⟫ ⇄ ¿
  ⌫ ¿

  k "while" ≡ ⤴ ↵
    stmt "cond" ⌈ ⌉ funmap ⟪ emit_expr ⟫ → cond ¿
    stmt "body" ⌈ ⌉ funmap ⟪ emit_block ⟫ → body ¿
    【】 → parts ¿
    parts "  while (1) {\n" ⟪ append ⟫ → parts ¿
    parts cond ⟪ append ⟫ → parts ¿
    parts "  UhValue _cond = uh_stack_pop(&st);\n  if (!uh_is_true(_cond)) break;\n" ⟪ append ⟫ → parts ¿
    parts body ⟪ append ⟫ → parts ¿
    parts "  }\n" ⟪ append ⟫ → parts ¿
    parts "" ⟪ join ⟫ ⇄ ¿
  ⌫ ¿

  k "for" ≡ ⤴ ↵
    stmt "iter" ⌈ ⌉ → iterName ¿
    stmt "range" ⌈ ⌉ → rangeSpec ¿
    stmt "expr" ⌈ ⌉ → seqExpr ¿
    stmt "body" ⌈ ⌉ funmap ⟪ emit_block ⟫ → body ¿
    【】 → parts ¿
    rangeSpec ∅ ≢ ⤴ ↵
      rangeSpec 0 ⌈ ⌉ → startExpr ¿
      rangeSpec 1 ⌈ ⌉ → endExpr ¿
      【startExpr】 funmap ⟪ emit_expr ⟫ → startCode ¿
      【endExpr】 funmap ⟪ emit_expr ⟫ → endCode ¿
      parts startCode ⟪ append ⟫ → parts ¿
      parts endCode ⟪ append ⟫ → parts ¿
      parts "  UhValue _end = uh_stack_pop(&st);\n  UhValue _start = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  for (long _i = (long)_start.num; _i < (long)_end.num; _i++) {\n" ⟪ append ⟫ → parts ¿
      "  uh_env_set(&env, \"" iterName ⊞⊞ "\", uh_num((double)_i));\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts body ⟪ append ⟫ → parts ¿
      parts "  }\n" ⟪ append ⟫ → parts ¿
    ⌫ ⤵ ↵
      seqExpr funmap ⟪ emit_expr ⟫ → seqCode ¿
      parts seqCode ⟪ append ⟫ → parts ¿
      parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  if (_seq.tag == UH_ARR && _seq.arr) {\n" ⟪ append ⟫ → parts ¿
      parts "    for (size_t _i = 0; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
      "      uh_env_set(&env, \"" iterName ⊞⊞ "\", _seq.arr->items[_i]);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts body ⟪ append ⟫ → parts ¿
      parts "    }\n  } else if (_seq.tag == UH_STR && _seq.str) {\n" ⟪ append ⟫ → parts ¿
      parts "    long _len = (long)uh_len(_seq).num;\n" ⟪ append ⟫ → parts ¿
      parts "    for (long _i = 0; _i < _len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _ch = uh_char_at(_seq, uh_num((double)_i));\n" ⟪ append ⟫ → parts ¿
      "      uh_env_set(&env, \"" iterName ⊞⊞ "\", _ch);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts body ⟪ append ⟫ → parts ¿
      parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    parts "" ⟪ join ⟫ ⇄ ¿
  ⌫ ¿

  "" ⇄ ¿
↦ stmt ↦ funmap ↦ emit_stmt ¿

ƒ
  【】 → parts ¿
  0 → i ¿
  expr ⟪ len ⟫ → n ¿
  i n ≺ ⟲ ↵
    expr i ⌈ ⌉ → t ¿
    t "kind" ⌈ ⌉ → k ¿
    t "value" ⌈ ⌉ → v ¿
    parts "{\n" ⟪ append ⟫ → parts ¿
    k "number" ≡ ⤴ ↵
      "  uh_stack_push(&st, uh_num(" v ⊞⊞ "));\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "string" ≡ ⤴ ↵
      v ⟪ escape_c_string ⟫ → esc ¿
      "  uh_stack_push(&st, uh_str(\"" esc ⊞⊞ "\"));\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "bool" ≡ ⤴ ↵
      "  uh_stack_push(&st, uh_num(" v ⊞⊞ "));\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "null" ≡ ⤴ ↵ parts "  uh_stack_push(&st, uh_null());\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
    k "ident" ≡ ⤴ ↵
      funmap v ⌈ ⌉ → fnargc ¿
      fnargc ∅ ≢ ⤴ ↵
        v ⟪ escape_c_string ⟫ → vesc ¿
        "  uh_stack_push(&st, uh_str(\"" vesc ⊞⊞ "\"));\n" ⊞⊞ → line ¿
        parts line ⟪ append ⟫ → parts ¿
      ⌫ ⤵ ↵
        "  uh_stack_push(&st, uh_env_get(&env, \"" v ⊞⊞ "\"));\n" ⊞⊞ → line ¿
        parts line ⟪ append ⟫ → parts ¿
      ⌫ ¿
    ⌫ ¿
    k "array" ≡ ⤴ ↵
      parts "  UhValue _arr = uh_arr_new();\n" ⟪ append ⟫ → parts ¿
      t "items" ⌈ ⌉ → items ¿
      items ⟪ len ⟫ → m ¿
      0 → j ¿
      j m ≺ ⟲ ↵
        items j ⌈ ⌉ → it ¿
        【it】 funmap ⟪ emit_expr ⟫ → piece ¿
        parts piece ⟪ append ⟫ → parts ¿
        parts "  uh_arr_push(&_arr, uh_stack_pop(&st));\n" ⟪ append ⟫ → parts ¿
        j 1 ⊞ → j ¿
      ⌫ ¿
      parts "  uh_stack_push(&st, _arr);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "dict" ≡ ⤴ ↵
      parts "  UhValue _dict = uh_dict_new();\n" ⟪ append ⟫ → parts ¿
      t "pairs" ⌈ ⌉ → pairs ¿
      pairs ⟪ len ⟫ → m ¿
      0 → j ¿
      j m ≺ ⟲ ↵
        pairs j ⌈ ⌉ "key" ⌈ ⌉ → k1 ¿
        pairs j ⌈ ⌉ "val" ⌈ ⌉ → v1 ¿
        【k1】 funmap ⟪ emit_expr ⟫ → pieceK ¿
        【v1】 funmap ⟪ emit_expr ⟫ → pieceV ¿
        parts "{\n" ⟪ append ⟫ → parts ¿
        parts pieceK ⟪ append ⟫ → parts ¿
        parts "  UhValue _k = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts pieceV ⟪ append ⟫ → parts ¿
        parts "  UhValue _v = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "  uh_dict_set(&_dict, _k, _v);\n" ⟪ append ⟫ → parts ¿
        parts "}\n" ⟪ append ⟫ → parts ¿
        j 1 ⊞ → j ¿
      ⌫ ¿
      parts "  uh_stack_push(&st, _dict);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "assign_field" ≡ ⤴ ↵
      t "base" ⌈ ⌉ → base ¿
      t "field" ⌈ ⌉ → field ¿
      field ⟪ escape_c_string ⟫ → fesc ¿
      parts "  UhValue _v = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      "  UhValue _obj = uh_env_get(&env, \"" base ⊞⊞ "\");\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      "  UhValue _key = uh_str(\"" fesc ⊞⊞ "\");\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts "  uh_store_index(&_obj, _key, _v);\n" ⟪ append ⟫ → parts ¿
      "  uh_env_set(&env, \"" base ⊞⊞ "\", _obj);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "assign" ≡ ⤴ ↵
      parts "  UhValue _v = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      "  uh_env_set(&env, \"" v ⊞⊞ "\", _v);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "reduce" ≡ ⤴ ↵
      t "op" ⌈ ⌉ → opv ¿
      parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  UhValue _acc = uh_num(0);\n" ⟪ append ⟫ → parts ¿
      parts "  if (_seq.tag == UH_ARR && _seq.arr && _seq.arr->len > 0) {\n" ⟪ append ⟫ → parts ¿
      parts "    _acc = _seq.arr->items[0];\n" ⟪ append ⟫ → parts ¿
      parts "    for (size_t _i = 1; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _v = _seq.arr->items[_i];\n" ⟪ append ⟫ → parts ¿
      opv "⊞" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num + _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊟" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num - _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊠" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num * _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊘" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num / _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
      parts "  uh_stack_push(&st, _acc);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "scan" ≡ ⤴ ↵
      t "op" ⌈ ⌉ → opv ¿
      parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  UhValue _out = uh_arr_new();\n" ⟪ append ⟫ → parts ¿
      parts "  if (_seq.tag == UH_ARR && _seq.arr && _seq.arr->len > 0) {\n" ⟪ append ⟫ → parts ¿
      parts "    UhValue _acc = _seq.arr->items[0];\n" ⟪ append ⟫ → parts ¿
      parts "    uh_arr_push(&_out, _acc);\n" ⟪ append ⟫ → parts ¿
      parts "    for (size_t _i = 1; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _v = _seq.arr->items[_i];\n" ⟪ append ⟫ → parts ¿
      opv "⊞" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num + _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊟" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num - _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊠" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num * _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      opv "⊘" ≡ ⤴ ↵ parts "      _acc = uh_num(_acc.num / _v.num);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      parts "      uh_arr_push(&_out, _acc);\n" ⟪ append ⟫ → parts ¿
      parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
      parts "  uh_stack_push(&st, _out);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "map" ≡ ⤴ ↵
      t "func" ⌈ ⌉ → fname ¿
      parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  UhValue _out = uh_arr_new();\n" ⟪ append ⟫ → parts ¿
      parts "  if (_seq.tag == UH_ARR && _seq.arr) {\n" ⟪ append ⟫ → parts ¿
      parts "    for (size_t _i = 0; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _arg = _seq.arr->items[_i];\n" ⟪ append ⟫ → parts ¿
      "      UhValue _ret = uh_fn_" fname ⊞⊞ "(&env, _arg);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts "      if (_ret.tag == UH_NUM && (_ret.num == 0 || _ret.num == 1)) {\n" ⟪ append ⟫ → parts ¿
      parts "        if (uh_is_true(_ret)) uh_arr_push(&_out, _arg);\n" ⟪ append ⟫ → parts ¿
      parts "      } else {\n" ⟪ append ⟫ → parts ¿
      parts "        uh_arr_push(&_out, _ret);\n" ⟪ append ⟫ → parts ¿
      parts "      }\n" ⟪ append ⟫ → parts ¿
      parts "    }\n  } else if (_seq.tag == UH_STR && _seq.str) {\n" ⟪ append ⟫ → parts ¿
      parts "    long _len = (long)uh_len(_seq).num;\n" ⟪ append ⟫ → parts ¿
      parts "    for (long _i = 0; _i < _len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _arg = uh_char_at(_seq, uh_num((double)_i));\n" ⟪ append ⟫ → parts ¿
      "      UhValue _ret = uh_fn_" fname ⊞⊞ "(&env, _arg);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts "      if (_ret.tag == UH_NUM && (_ret.num == 0 || _ret.num == 1)) {\n" ⟪ append ⟫ → parts ¿
      parts "        if (uh_is_true(_ret)) uh_arr_push(&_out, _arg);\n" ⟪ append ⟫ → parts ¿
      parts "      } else {\n" ⟪ append ⟫ → parts ¿
      parts "        uh_arr_push(&_out, _ret);\n" ⟪ append ⟫ → parts ¿
      parts "      }\n" ⟪ append ⟫ → parts ¿
      parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
      parts "  uh_stack_push(&st, _out);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "map_lambda" ≡ ⤴ ↵
      t "lambda" ⌈ ⌉ → lam ¿
      lam "param" ⌈ ⌉ → lparam ¿
      lam "body" ⌈ ⌉ funmap ⟪ emit_expr ⟫ → lbody ¿
      parts "  UhValue _seq = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "  UhValue _out = uh_arr_new();\n" ⟪ append ⟫ → parts ¿
      parts "  if (_seq.tag == UH_ARR && _seq.arr) {\n" ⟪ append ⟫ → parts ¿
      parts "    for (size_t _i = 0; _i < _seq.arr->len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _arg = _seq.arr->items[_i];\n" ⟪ append ⟫ → parts ¿
      "      uh_env_set(&env, \"" lparam ⊞⊞ "\", _arg);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts lbody ⟪ append ⟫ → parts ¿
      parts "      UhValue _ret = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "      if (_ret.tag == UH_NUM && (_ret.num == 0 || _ret.num == 1)) {\n" ⟪ append ⟫ → parts ¿
      parts "        if (uh_is_true(_ret)) uh_arr_push(&_out, _arg);\n" ⟪ append ⟫ → parts ¿
      parts "      } else {\n" ⟪ append ⟫ → parts ¿
      parts "        uh_arr_push(&_out, _ret);\n" ⟪ append ⟫ → parts ¿
      parts "      }\n" ⟪ append ⟫ → parts ¿
      parts "    }\n  } else if (_seq.tag == UH_STR && _seq.str) {\n" ⟪ append ⟫ → parts ¿
      parts "    long _len = (long)uh_len(_seq).num;\n" ⟪ append ⟫ → parts ¿
      parts "    for (long _i = 0; _i < _len; _i++) {\n" ⟪ append ⟫ → parts ¿
      parts "      UhValue _arg = uh_char_at(_seq, uh_num((double)_i));\n" ⟪ append ⟫ → parts ¿
      "      uh_env_set(&env, \"" lparam ⊞⊞ "\", _arg);\n" ⊞⊞ → line ¿
      parts line ⟪ append ⟫ → parts ¿
      parts lbody ⟪ append ⟫ → parts ¿
      parts "      UhValue _ret = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
      parts "      if (_ret.tag == UH_NUM && (_ret.num == 0 || _ret.num == 1)) {\n" ⟪ append ⟫ → parts ¿
      parts "        if (uh_is_true(_ret)) uh_arr_push(&_out, _arg);\n" ⟪ append ⟫ → parts ¿
      parts "      } else {\n" ⟪ append ⟫ → parts ¿
      parts "        uh_arr_push(&_out, _ret);\n" ⟪ append ⟫ → parts ¿
      parts "      }\n" ⟪ append ⟫ → parts ¿
      parts "    }\n  }\n" ⟪ append ⟫ → parts ¿
      parts "  uh_stack_push(&st, _out);\n" ⟪ append ⟫ → parts ¿
    ⌫ ¿
    k "call" ≡ ⤴ ↵
      "" → callName ¿
      v → callName ¿
      callName → callLookup ¿
      callName ⟪ len ⟫ → clen ¿
      clen 0 ≻ ⤴ ↵
        callName 0 ⟪ char_at ⟫ "." ≡ ⤴ ↵
          callName 1 clen 1 ⊟ ⟪ substr ⟫ → callLookup ¿
        ⌫ ¿
      ⌫ ¿
      0 → argc ¿
      "uh_fn_" callLookup ⊞⊞ → callee ¿
      ⊥ → isBuiltin ¿
      ⊥ → isDynCall0 ¿

      funmap callLookup ⌈ ⌉ → fnargc ¿
      fnargc ∅ ≢ ⤴ ↵ fnargc → argc ¿ ⌫ ¿

      callName "call" ≡ callName ".call" ≡ ∨ ⤴ ↵ 1 → argc ¿ ⊤ → isDynCall0 ¿ ⌫ ¿
      callName "len" ≡ callName ".len" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_len" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "char_at" ≡ callName ".char_at" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_char_at" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "read_file" ≡ ⤴ ↵ 1 → argc ¿ "uh_read_file" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".read" ≡ ⤴ ↵ 1 → argc ¿ "uh_file_read" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".readall" ≡ ⤴ ↵ 1 → argc ¿ "uh_file_readall" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".readlines" ≡ ⤴ ↵ 1 → argc ¿ "uh_file_readlines" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "write_file" ≡ ⤴ ↵ 2 → argc ¿ "uh_write_file" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".write" ≡ ⤴ ↵ 2 → argc ¿ "uh_file_write" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".close" ≡ ⤴ ↵ 1 → argc ¿ "uh_file_close" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "syscall" ≡ callName ".syscall" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_syscall" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "args" ≡ callName ".args" ≡ ∨ ⤴ ↵ 0 → argc ¿ "uh_args" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "split" ≡ callName ".split" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_split" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "join" ≡ callName ".join" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_join" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "append" ≡ callName ".append" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_append" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "substr" ≡ callName ".substr" ≡ ∨ ⤴ ↵ 3 → argc ¿ "uh_substr" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "import" ≡ callName ".import" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_import" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "json.parse" ≡ ⤴ ↵ 1 → argc ¿ "uh_json_parse" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "json.stringify" ≡ ⤴ ↵ 1 → argc ¿ "uh_json_stringify" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "type" ≡ callName ".type" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_type" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "int" ≡ callName ".int" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_int" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "float" ≡ callName ".float" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_float" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "upper" ≡ callName ".upper" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_upper" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "lower" ≡ callName ".lower" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_lower" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "indexOf" ≡ callName ".indexOf" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_index_of" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "startsWith" ≡ callName ".startsWith" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_starts_with" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "match" ≡ callName ".match" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_match" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "chunk" ≡ callName ".chunk" ≡ ∨ ⤴ ↵ 2 → argc ¿ "uh_chunk" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "format" ≡ callName ".format" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_format" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "hex" ≡ callName ".hex" ≡ ∨ ⤴ ↵ 1 → argc ¿ "uh_hex" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "time.now" ≡ ⤴ ↵ 0 → argc ¿ "uh_time_now" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "http.get" ≡ ⤴ ↵ 1 → argc ¿ "uh_http_get" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "http.request" ≡ ⤴ ↵ 1 → argc ¿ "uh_http_request" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "http.handle" ≡ ⤴ ↵ 2 → argc ¿ "uh_http_handle" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "http.listen" ≡ ⤴ ↵ 1 → argc ¿ "uh_http_listen" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".method" ≡ ⤴ ↵ 1 → argc ¿ "uh_http_method" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".json" ≡ ⤴ ↵ 2 → argc ¿ "uh_http_json" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "db.connect" ≡ ⤴ ↵ 1 → argc ¿ "uh_db_connect" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".exec" ≡ ⤴ ↵ 2 → argc ¿ "uh_db_exec" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".query" ≡ ⤴ ↵ 2 → argc ¿ "uh_db_query" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".begin" ≡ ⤴ ↵ 1 → argc ¿ "uh_db_begin" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".commit" ≡ ⤴ ↵ 1 → argc ¿ "uh_db_commit" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".thread" ≡ ⤴ ↵ 2 → argc ¿ "uh_thread_start" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".join" ≡ ⤴ ↵ 1 → argc ¿ "uh_thread_join" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".lock" ≡ ⤴ ↵ 1 → argc ¿ "uh_mutex_lock" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".unlock" ≡ ⤴ ↵ 1 → argc ¿ "uh_mutex_unlock" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "ws.serve" ≡ ⤴ ↵ 1 → argc ¿ "uh_ws_serve" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "ws.connect" ≡ ⤴ ↵ 1 → argc ¿ "uh_ws_connect" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".receive" ≡ ⤴ ↵ 1 → argc ¿ "uh_ws_receive" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".send" ≡ ⤴ ↵ 2 → argc ¿ "uh_send" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "smtp.connect" ≡ ⤴ ↵ 1 → argc ¿ "uh_smtp_connect" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName ".disconnect" ≡ ⤴ ↵ 1 → argc ¿ "uh_smtp_disconnect" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "crypto.sha256" ≡ ⤴ ↵ 1 → argc ¿ "uh_crypto_sha256" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "crypto.randomBytes" ≡ ⤴ ↵ 1 → argc ¿ "uh_crypto_random_bytes" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "crypto.encryptAES" ≡ ⤴ ↵ 2 → argc ¿ "uh_crypto_encrypt_aes" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "crypto.decryptAES" ≡ ⤴ ↵ 2 → argc ¿ "uh_crypto_decrypt_aes" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿
      callName "crypto.hmacSHA256" ≡ ⤴ ↵ 2 → argc ¿ "uh_crypto_hmac_sha256" → callee ¿ ⊤ → isBuiltin ¿ ⌫ ¿

      isDynCall0 ⤴ ↵
        parts "  UhValue _fn = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "  if (_fn.tag == UH_STR && _fn.str) {\n" ⟪ append ⟫ → parts ¿
        parts "    const char *_name = _fn.str;\n" ⟪ append ⟫ → parts ¿
        parts "    int _called = 0;\n" ⟪ append ⟫ → parts ¿
        funmap "keys" ⌈ ⌉ → fnames ¿
        fnames ⟪ len ⟫ → fnlen ¿
        0 → fi ¿
        fi fnlen ≺ ⟲ ↵
          fnames fi ⌈ ⌉ → fname ¿
          fname ⟪ escape_c_string ⟫ → fesc ¿
          "    if (!_called && strcmp(_name, \"" fesc ⊞⊞ "\") == 0) { UhValue _call = uh_fn_" ⊞⊞ fname ⊞⊞ "(&env); uh_stack_push(&st, _call); _called = 1; }\n" ⊞⊞ → line ¿
          parts line ⟪ append ⟫ → parts ¿
          fi 1 ⊞ → fi ¿
        ⌫ ¿
        parts "    if (!_called) { uh_stack_push(&st, uh_num(0)); }\n" ⟪ append ⟫ → parts ¿
        parts "  } else { uh_stack_push(&st, uh_num(0)); }\n" ⟪ append ⟫ → parts ¿
      ⌫ ⤵ ↵
      argc 0 ≡ ⤴ ↵
        isBuiltin ⤴ ↵
          "  UhValue _call = " callee ⊞⊞ "();\n  uh_stack_push(&st, _call);\n" ⊞⊞ → line ¿
          parts line ⟪ append ⟫ → parts ¿
        ⌫ ⤵ ↵
          "  UhValue _call = " callee ⊞⊞ "(&env);\n  uh_stack_push(&st, _call);\n" ⊞⊞ → line ¿
          parts line ⟪ append ⟫ → parts ¿
        ⌫ ¿
      ⌫ ¿

      isDynCall0 ⊥ ≡ argc 0 ≻ ∧ ⤴ ↵
        "" → popCode ¿
        argc 1 ⊟ → j ¿
        j 0 ≽ ⟲ ↵
          popCode "  UhValue _a" ⊞⊞ j ⍕ ⊞⊞ " = uh_stack_pop(&st);\n" ⊞⊞ → popCode ¿
          j 1 ⊟ → j ¿
        ⌫ ¿
        "" → argsCode ¿
        0 → j ¿
        j argc ≺ ⟲ ↵
          j 0 ≻ ⤴ ↵ argsCode ", " ⊞⊞ → argsCode ¿ ⌫ ¿
          argsCode "_a" ⊞⊞ j ⍕ ⊞⊞ → argsCode ¿
          j 1 ⊞ → j ¿
        ⌫ ¿
        parts popCode ⟪ append ⟫ → parts ¿
        isBuiltin ⤴ ↵
          "  UhValue _call = " callee ⊞⊞ "(" ⊞⊞ argsCode ⊞⊞ ");\n  uh_stack_push(&st, _call);\n" ⊞⊞ → line ¿
          parts line ⟪ append ⟫ → parts ¿
        ⌫ ⤵ ↵
          "  UhValue _call = " callee ⊞⊞ "(&env" ⊞⊞ → line ¿
          argsCode "" ≡ ⤴ ↵
            line ");\n  uh_stack_push(&st, _call);\n" ⊞⊞ → line ¿
          ⌫ ⤵ ↵
            line ", " ⊞⊞ argsCode ⊞⊞ ");\n  uh_stack_push(&st, _call);\n" ⊞⊞ → line ¿
          ⌫ ¿
          parts line ⟪ append ⟫ → parts ¿
        ⌫ ¿
      ⌫ ¿
    ⌫ ¿
    ⌫ ¿
    k "op" ≡ ⤴ ↵
      v "⊞" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_add(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊟" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_sub(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊠" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_mul(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊘" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_div(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊙" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num((long)a.num % (long)b.num));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊛" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_pow(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊞⊞" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_concat(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊟⊟" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_drop(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊡" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_take(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊚" ≡ ⤴ ↵ parts "  UhValue c = uh_stack_pop(&st); UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_reshape(a, b, c));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⌽" ≡ ⤴ ↵ parts "  UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_reverse(a));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊖" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_rotate(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⍉" ≡ ⤴ ↵ parts "  UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_transpose(a));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⌈" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_index(a, b));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "store_index" ≡ ⤴ ↵ parts "  UhValue v0 = uh_stack_pop(&st); UhValue k0 = uh_stack_pop(&st); UhValue c0 = uh_stack_pop(&st); uh_store_index(&c0, k0, v0);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∈" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_contains(b, a)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∋" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_contains(a, b)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊂" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_subset(a, b, 1)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊆" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_subset(a, b, 0)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≡" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_value_eq(a, b))); \n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≢" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(!uh_value_eq(a, b))); \n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≺" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_cmp(a, b) < 0));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≻" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_cmp(a, b) > 0));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≼" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_cmp(a, b) <= 0));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "≽" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_cmp(a, b) >= 0));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∧" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_is_true(a) && uh_is_true(b)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∨" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(uh_is_true(a) || uh_is_true(b)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "¬" ≡ ⤴ ↵ parts "  UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num(!uh_is_true(a)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊕⊕" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); int av = uh_is_true(a); int bv = uh_is_true(b); uh_stack_push(&st, uh_num((av && !bv) || (!av && bv)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "◁" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num((double)((long)a.num << (long)b.num)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "▷" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num((double)((long)a.num >> (long)b.num)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∩" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num((double)((long)a.num & (long)b.num)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "∪" ≡ ⤴ ↵ parts "  UhValue b = uh_stack_pop(&st); UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_num((double)((long)a.num | (long)b.num)));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⍕" ≡ ⤴ ↵ parts "  UhValue a = uh_stack_pop(&st); uh_stack_push(&st, uh_stringify(a));\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⊢" ≡ ⤴ ↵ parts "  UhValue v = uh_stack_pop(&st); uh_print(v);\n" ⟪ append ⟫ → parts ¿ ⌫ ¿
      v "⌸" ≡ ⤴ ↵
        parts "  if (st.len >= 3) {\n" ⟪ append ⟫ → parts ¿
        parts "    UhValue _mode = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "    UhValue _path = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "    UhValue _data = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "    uh_stack_push(&st, uh_write_file(_path, _data));\n" ⟪ append ⟫ → parts ¿
        parts "  } else {\n" ⟪ append ⟫ → parts ¿
        parts "    UhValue _mode = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "    UhValue _path = uh_stack_pop(&st);\n" ⟪ append ⟫ → parts ¿
        parts "    uh_stack_push(&st, uh_file_open(_path, _mode));\n" ⟪ append ⟫ → parts ¿
        parts "  }\n" ⟪ append ⟫ → parts ¿
      ⌫ ¿
    ⌫ ¿
    parts "}\n" ⟪ append ⟫ → parts ¿
    i 1 ⊞ → i ¿
  ⌫ ¿
  parts "" ⟪ join ⟫ ⇄ ¿
↦ expr ↦ funmap ↦ emit_expr ¿
